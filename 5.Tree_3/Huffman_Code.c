/*5.3 Huffman Codes
In 1953, David A. Huffman published his paper "A Method for the Construction of Minimum-Redundancy Codes", 
and hence printed his name in the history of computer science. 
As a professor who gives the final exam problem on Huffman codes, 
I am encountering a big problem: the Huffman codes are NOT unique. For example, given a string "aaaxuaxz", 
we can observe that the frequencies of the characters 'a', 'x', 'u' and 'z' are 4, 2, 1 and 1, respectively. 
We may either encode the symbols as {'a'=0, 'x'=10, 'u'=110, 'z'=111}, or in another way as {'a'=1, 'x'=01, 'u'=001, 'z'=000}, 
both compress the string into 14 bits. 
Another set of code can be given as {'a'=0, 'x'=11, 'u'=100, 'z'=101}, 
but {'a'=0, 'x'=01, 'u'=011, 'z'=001} is NOT correct since "aaaxuaxz" and "aazuaxax" can both be decoded from the code 00001011001001. 
The students are submitting all kinds of codes, 
and I need a computer program to help me determine which ones are correct and which ones are not.

Input Specification:
Each input file contains one test case. For each case, the first line gives an integer N (2≤N≤63), 
then followed by a line that contains all the N distinct characters and their frequencies in the following format:

c[1] f[1] c[2] f[2] ... c[N] f[N]
where c[i] is a character chosen from {'0' - '9', 'a' - 'z', 'A' - 'Z', '_'}, 
and f[i] is the frequency of c[i] and is an integer no more than 1000. 
The next line gives a positive integer M (≤1000), then followed by M student submissions.
Each student submission consists of N lines, each in the format:

c[i] code[i]
where c[i] is the i-th character and code[i] is an non-empty string of no more than 63 '0's and '1's.

Output Specification:
For each test case, print in each line either "Yes" if the student's submission is correct, or "No" if not.

Note: The optimal solution is not necessarily generated by Huffman algorithm. 
Any prefix code with code length being optimal is considered correct.

Sample Input:
7
A 1 B 1 C 1 D 3 E 3 F 6 G 6
4
A 00000
B 00001
C 0001
D 001
E 01
F 10
G 11
A 01010
B 01011
C 0100
D 011
E 10
F 11
G 00
A 000
B 001
C 010
D 011
E 100
F 101
G 110
A 00000
B 00001
C 0001
D 001
E 00
F 10
G 11
Sample Output:
Yes
Yes
No
No
*/

#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>
#include<string.h>
#define MAXN 64
typedef struct TreeNode *HuffmanTree;
struct TreeNode
{
    int Weight;
    HuffmanTree Left;
    HuffmanTree Right;
};

typedef struct HNode *Heap; /* 堆的类型定义 */
struct HNode
{
    HuffmanTree Data;   /* 存储元素的数组 */
    int Size;    /* 堆中当前元素个数 */
    int Capacity;   /* 堆的最大容量 */
};
typedef Heap MinHeap;   /* 最小堆 */
#define MINDATA -1000   /* 该值应根据具体情况定义为小于堆中所有可能元素的值 */

MinHeap CreateMinHeap(int MaxSize)
{ /* 创建容量为MaxSize的空的最小堆 */
    MinHeap H=(MinHeap)malloc(sizeof(struct HNode));
    H->Data=(HuffmanTree)malloc((MaxSize+1)*sizeof(struct TreeNode));
    H->Size=0;
    H->Capacity=MaxSize;
    H->Data[0].Weight=MINDATA; /* 定义"哨兵"为小于堆中所有可能元素的值*/
    return H;
}

bool IsFull(MinHeap H)
{
    return (H->Size==H->Capacity);
}

void Insert(MinHeap H,HuffmanTree T)
{/* 将元素X插入最小堆H，其中H->Data[0]已经定义为哨兵 */
    int i;
    if(IsFull(H))
        printf("NO\n");
    i=++H->Size;    /* i指向插入后堆中的最后一个元素的位置 */
    for(;H->Data[i/2].Weight>T->Weight;i/=2)   /* 上滤X */
        H->Data[i]=H->Data[i/2];
    H->Data[i]=*T;   /* 将X插入 */
}

bool IsEmpty(MinHeap H)
{
    return (H->Size==0);
}

HuffmanTree DeleteMin(MinHeap H)
{/* 从最小堆H中取出键值为最小的元素，并删除一个结点 */
    int Parent,Child;
    HuffmanTree MinItem,X;
    MinItem=(HuffmanTree)malloc(sizeof(struct TreeNode));
    X=(HuffmanTree)malloc(sizeof(struct TreeNode));
    if(IsEmpty(H))
        printf("NO\n");
    *MinItem=H->Data[1];   /* 取出根结点存放的最小值 */
    *X=H->Data[H->Size--]; /* 用最小堆中最后一个元素从根结点开始向上过滤下层结点 */
    for(Parent=1;Parent*2<=H->Size;Parent=Child)
    {
        Child=Parent*2;
        if((Child!=H->Size) && (H->Data[Child].Weight>H->Data[Child+1].Weight))
            Child++;    /* Child指向左右子结点的较小者 */
        if(X->Weight<=H->Data[Child].Weight)
            break;  /* 找到了合适位置 */
        else    /* 下滤X */
            H->Data[Parent]=H->Data[Child];
    }
    H->Data[Parent]=*X;
    return MinItem;
}

/*----------- 建造最小堆 -----------*/
void PercDown(MinHeap H,int p)
{
    int Parent,Child;
    HuffmanTree X=(HuffmanTree)malloc(sizeof(struct TreeNode));
    *X=H->Data[p];
    for(Parent=p;Parent*2<=H->Size;Parent=Child)
    {
        Child=Parent*2;
        if((Child!=H->Size) && (H->Data[Child].Weight>H->Data[Child+1].Weight))
            Child++;
        if(X->Weight<H->Data[Child].Weight)
            break;
        else
            H->Data[Parent]=H->Data[Child];
    }
    H->Data[Parent]=*X;
}

void BuildMinHeap(MinHeap H)
{/* 调整H->Data[]中的元素，使满足最大堆的有序性  */
/* 这里假设所有H->Size个元素已经存在H->Data[]中 */
    int i;
    /* 从最后一个结点的父节点开始，到根结点1 */
    for(i=H->Size/2;i>0;i--)
        PercDown(H,i);
}

HuffmanTree Huffman(MinHeap H)
{
    int i;
    HuffmanTree T=(HuffmanTree)malloc(sizeof(struct TreeNode));
    //BuildMinHeap(H);
    for(i=1;i<H->Size;)
    {
        T=(HuffmanTree)malloc(sizeof(struct TreeNode));
        T->Left=DeleteMin(H);
        T->Right=DeleteMin(H);
        T->Weight=T->Left->Weight+T->Right->Weight;
        Insert(H,T);
    }
    T=DeleteMin(H);
    return T;
}

int WPL(HuffmanTree T,int Depth)//计算Huffman树的编码长度
{
    int rw=0, lw=0;
    if(!T->Left && !T->Right)
        return (Depth*(T->Weight));
    else
    {
        if(T->Left) lw = WPL(T->Left, Depth+1);
        if(T->Right) rw = WPL(T->Right, Depth+1);
        return lw+rw;
    }
}

/*int WPL(TreeNode *T,int Depth)//计算Huffman树的编码长度  
{  
    if (!T->Left && !T->Right)  
    {  
        return Depth*(T->Weight);  
    }else  
    {  
        return (WPL(T->Left,Depth+1)+WPL(T->Right,Depth+1));  
    }  
}*/

HuffmanTree CreateHuffmanTree()
{
    HuffmanTree T=(HuffmanTree)malloc(sizeof(struct TreeNode));
    T->Weight=0;
    T->Left=T->Right=NULL;
    return T;
}

void DeleteHuffmanTree(HuffmanTree T)
{
    if(T)
    {
        DeleteHuffmanTree(T->Left);
        DeleteHuffmanTree(T->Right);
        free(T);
    }
}

bool Judge(int N,int CodeLen,char *ch,int *cf)
{
    char s1[MAXN],s2[MAXN];
    int i,j,weight,flag=1;
    HuffmanTree T=CreateHuffmanTree();
    HuffmanTree pt=NULL;
    for(i=0;i<N;i++)
    {
        scanf("%s %s",s1,s2);
        if(strlen(s2)>N)
        {
            flag=0;
            break;
        }
        for(j=0;s1[0]!=ch[j];j++)
            if(j==N)
            {
                flag=0;
                break;
            }
        weight=cf[j];
        pt=T;
        for(j=0;j<strlen(s2);j++)
        {
            if(s2[j]=='0')  //开始创建树
            {
                if(!pt->Left)
                    pt->Left=CreateHuffmanTree();    //没有就创建
                else if(pt->Left->Weight!=0)
                    flag=0; //是否路过叶子
                pt=pt->Left;
            }
            else if(s2[j]=='1')
            {
                if(!pt->Right)
                    pt->Right=CreateHuffmanTree();
                else if(pt->Right->Weight!=0)
                    flag=0;
                pt=pt->Right;
            }
            else
                flag=0;
        }
        pt->Weight=weight;  //叶子标记
        weight=0;   //清空weight
        if(pt->Left || pt->Right)
            flag=0;
    }
    if(flag==1 && CodeLen==WPL(T,0))
        return true;
    else
    {
        if(T)
            DeleteHuffmanTree(T);
        return false;
    }
}

int main()
{
    int N,CodeLen,n,i;
    MinHeap H;
    char *ch;
    int *cf;
    scanf("%d\n",&N);
    H=CreateMinHeap(N);
    ch=(char *)malloc(sizeof(char)*N);
    cf=(int *)malloc(sizeof(int)*N);
    for(i=0;i<N;i++)
    {
        if(i==N-1)
            scanf("%c %d",&ch[i],&cf[i]);
        else
            scanf("%c %d ",&ch[i],&cf[i]);
            HuffmanTree temp=(HuffmanTree)malloc(sizeof(struct TreeNode));
            temp->Left=temp->Right=NULL;
            temp->Weight=cf[i];
            Insert(H,temp);
    }
    HuffmanTree T=(HuffmanTree)malloc(sizeof(struct TreeNode));
    T=Huffman(H);
    CodeLen=WPL(T,0);
    scanf("%d",&n);
    for(i=0;i<n;i++)
    {
        if(Judge(N,CodeLen,ch,cf))
            printf("Yes\n");
        else
            printf("No\n");
    }
    return 0;
}
